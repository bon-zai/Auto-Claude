{
  "id": "ideation-20251212-104105",
  "project_id": "/Users/andremikalsen/Documents/Coding/autonomous-coding",
  "config": {
    "enabled_types": [
      "code_quality"
    ],
    "include_roadmap_context": true,
    "include_kanban_context": true,
    "max_ideas_per_type": 5
  },
  "ideas": [
    {
      "id": "cq-001",
      "type": "code_quality",
      "title": "Split monolithic spec_runner.py into focused modules",
      "description": "The spec_runner.py file has grown to 1802 lines and handles multiple concerns: complexity assessment, phase orchestration, spec creation, and CLI interface. This violates single responsibility principle and makes the code difficult to navigate and maintain.",
      "rationale": "Large files increase cognitive load, make code reviews harder, and often lead to merge conflicts. The file mixes high-level orchestration logic with detailed implementation, making it hard to understand the overall flow. Splitting it would improve testability and maintainability.",
      "category": "large_files",
      "severity": "major",
      "affectedFiles": [
        "auto-claude/spec_runner.py"
      ],
      "currentState": "Single 1802-line file handling complexity assessment, phase orchestration, spec creation, validation, and CLI interface",
      "proposedChange": "Split into: spec_runner.py (main CLI), complexity_analyzer.py (assessment logic), phase_orchestrator.py (pipeline management), and spec_creator.py (creation logic)",
      "codeExample": "# Current structure (all in one file):\nclass ComplexityAnalyzer: ...\nclass SpecOrchestrator: ...\ndef main(): ...\n\n# Proposed structure:\n# spec_runner.py - CLI entry point\n# complexity/analyzer.py - ComplexityAnalyzer class\n# orchestration/phases.py - Phase management\n# creation/spec_creator.py - Spec creation logic",
      "bestPractice": "Single Responsibility Principle - each module should have one well-defined purpose",
      "metrics": {
        "lineCount": 1802,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": [
        "Ensure comprehensive test coverage before refactoring",
        "Document current module interactions"
      ],
      "status": "dismissed"
    },
    {
      "id": "cq-002",
      "type": "code_quality",
      "title": "Extract duplicate environment and path setup code",
      "description": "Identical environment setup and path manipulation code is duplicated across 7 runner files (spec_runner.py, run.py, ideation_runner.py, roadmap_runner.py, etc.). Each file has the same 10-15 lines for .env loading and sys.path.insert operations.",
      "rationale": "Code duplication leads to maintenance overhead and inconsistency. When environment setup logic needs to change, it must be updated in multiple places, increasing the risk of bugs and inconsistencies.",
      "category": "duplication",
      "severity": "minor",
      "affectedFiles": [
        "auto-claude/spec_runner.py",
        "auto-claude/run.py",
        "auto-claude/ideation_runner.py",
        "auto-claude/roadmap_runner.py",
        "auto-claude/insights_runner.py",
        "auto-claude/test_graphiti_memory.py",
        "auto-claude/statusline.py"
      ],
      "currentState": "7 files each containing identical 10-15 lines for environment setup: sys.path.insert, load_dotenv with dev/auto-claude fallback",
      "proposedChange": "Create auto-claude/bootstrap.py module with setup_environment() function that handles path setup and .env loading, then import and call it in each runner",
      "codeExample": "# Current (repeated 7 times):\nsys.path.insert(0, str(Path(__file__).parent))\nfrom dotenv import load_dotenv\nenv_file = Path(__file__).parent / \".env\"\ndev_env_file = Path(__file__).parent.parent / \"dev\" / \"auto-claude\" / \".env\"\nif env_file.exists():\n    load_dotenv(env_file)\nelif dev_env_file.exists():\n    load_dotenv(dev_env_file)\n\n# Proposed:\n# bootstrap.py\ndef setup_environment() -> None: ...\n\n# In each runner:\nfrom bootstrap import setup_environment\nsetup_environment()",
      "bestPractice": "DRY (Don't Repeat Yourself) - extract common initialization logic into reusable utilities",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": 105,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": null
    },
    {
      "id": "cq-003",
      "type": "code_quality",
      "title": "Consolidate project_analyzer.py large file with clear module boundaries",
      "description": "The project_analyzer.py file at 1577 lines contains multiple distinct responsibilities: command registries, technology detection, security profiling, and file analysis. The file has grown organically and would benefit from being split into focused modules.",
      "rationale": "While this file is large, it's well-structured with clear sections. However, the mixing of static data (command registries), detection logic, and security profiling makes it harder to maintain and test individual components.",
      "category": "large_files",
      "severity": "minor",
      "affectedFiles": [
        "auto-claude/project_analyzer.py"
      ],
      "currentState": "1577-line file containing command registries, technology detection, security profiling, and caching logic all in one module",
      "proposedChange": "Split into: security/command_registry.py (command mappings), detection/technology_detector.py (stack detection), security/profile_builder.py (security profile creation), and project_analyzer.py (main interface)",
      "codeExample": "# Current structure (all in one file):\nBASE_COMMANDS = { ... }  # ~200 lines\nLANGUAGE_COMMANDS = { ... }  # ~300 lines\nclass ProjectAnalyzer: ...  # ~800 lines\n\n# Proposed structure:\n# security/commands.py - Command registries\n# detection/stack.py - Technology detection\n# security/profile.py - Profile building\n# project_analyzer.py - Main coordinator class",
      "bestPractice": "Separation of concerns - separate data definitions, business logic, and coordination",
      "metrics": {
        "lineCount": 1577,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": [
        "Maintain backward compatibility for existing imports",
        "Ensure comprehensive test coverage"
      ]
    },
    {
      "id": "cq-004",
      "type": "code_quality",
      "title": "Add missing Python linting and formatting configuration",
      "description": "The project lacks centralized code style configuration (no .flake8, .pylintrc, pyproject.toml with tool sections, or black configuration). Print statements are used extensively (703 occurrences) instead of proper logging, and there's no apparent consistent formatting standard.",
      "rationale": "Without automated linting and formatting, code quality can drift over time, leading to inconsistent style, potential bugs, and reduced readability. Print statements make debugging harder and pollute output.",
      "category": "linting",
      "severity": "minor",
      "affectedFiles": [
        "multiple files across the project"
      ],
      "currentState": "No centralized linting configuration, 703 print statements across 31 files, no apparent formatting standards",
      "proposedChange": "Add pyproject.toml with black, flake8, and mypy configuration. Create a logging utility to replace raw print statements with proper log levels. Add pre-commit hooks for automated formatting.",
      "codeExample": "# Add to pyproject.toml:\n[tool.black]\nline-length = 100\ntarget-version = ['py39']\n\n[tool.flake8]\nmax-line-length = 100\nignore = ['E203', 'W503']\n\n# Replace print statements:\n# Before: print(f\"Processing chunk {chunk_id}\")\n# After: logger.info(f\"Processing chunk {chunk_id}\")",
      "bestPractice": "Consistent code style and proper logging improve maintainability and debugging capability",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": [
        "Decide on line length and style preferences",
        "Plan migration strategy for print statements"
      ]
    },
    {
      "id": "cq-005",
      "type": "code_quality",
      "title": "Improve type safety with stricter type annotations",
      "description": "While the codebase has good type annotation coverage (422 functions with return type annotations), there are opportunities to improve type safety by adding more precise types for complex data structures like implementation plans, chunks, and configuration objects that are often passed around as generic dictionaries.",
      "rationale": "Type safety helps catch bugs at development time and improves IDE support. The codebase uses many dictionary-based data structures that could benefit from TypedDict or dataclass definitions for better type checking and documentation.",
      "category": "types",
      "severity": "suggestion",
      "affectedFiles": [
        "auto-claude/implementation_plan.py",
        "auto-claude/agent.py",
        "auto-claude/planner.py",
        "auto-claude/progress.py"
      ],
      "currentState": "Good type annotation coverage but heavy use of generic dict types for structured data like chunks, specs, and configuration",
      "proposedChange": "Define TypedDict classes for chunk data, spec configuration, and other frequently-used data structures. Consider converting some dictionary-heavy code to use dataclasses.",
      "codeExample": "# Current:\ndef process_chunk(chunk: dict) -> dict:\n    chunk_id = chunk[\"id\"]\n    description = chunk[\"description\"]\n    ...\n\n# Proposed:\nfrom typing import TypedDict\n\nclass ChunkData(TypedDict):\n    id: str\n    description: str\n    status: ChunkStatus\n    dependencies: List[str]\n\ndef process_chunk(chunk: ChunkData) -> ChunkResult:\n    ...",
      "bestPractice": "Strong typing improves code reliability and developer experience through better IDE support and compile-time error detection",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": [
        "Audit existing dictionary usage patterns",
        "Plan gradual migration strategy"
      ]
    }
  ],
  "project_context": {
    "existing_features": [],
    "tech_stack": [],
    "target_audience": null,
    "planned_features": []
  },
  "summary": {
    "total_ideas": 5,
    "by_type": {
      "code_quality": 5
    },
    "by_status": {
      "draft": 5
    }
  },
  "generated_at": "2025-12-12T10:41:05.715013",
  "updated_at": "2025-12-12T09:41:44.342Z"
}