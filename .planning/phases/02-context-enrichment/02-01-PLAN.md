---
phase: 02-context-enrichment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/runners/github/context_gatherer.py
autonomous: true

must_haves:
  truths:
    - "Path alias imports (@/utils, ~/) are detected from TypeScript files"
    - "CommonJS require() calls are detected"
    - "Re-exports (export * from) are detected"
    - "tsconfig.json paths mapping is parsed and used for resolution"
  artifacts:
    - path: "apps/backend/runners/github/context_gatherer.py"
      provides: "Extended JS/TS import detection"
      contains: "_load_tsconfig_paths"
      contains: "_resolve_path_alias"
  key_links:
    - from: "_find_imports()"
      to: "_load_tsconfig_paths()"
      via: "method call when detecting alias imports"
      pattern: "_load_tsconfig_paths|_resolve_path_alias"
---

<objective>
Extend JS/TS import analysis to detect path aliases, CommonJS requires, and re-exports.

Purpose: Currently `_find_imports()` only detects relative imports (`./` and `../`). Missing path alias imports like `@/utils` causes incomplete related files context, leading to false positive findings about "missing" code that actually exists.

Output: Enhanced import detection that resolves `@/`, `~/`, and other tsconfig path aliases to actual file paths.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-context-enrichment/02-RESEARCH.md
@apps/backend/runners/github/context_gatherer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tsconfig.json path alias loading</name>
  <files>apps/backend/runners/github/context_gatherer.py</files>
  <action>
Add two new methods to PRContextGatherer class (after `_find_type_definitions`):

1. `_load_json_safe(self, filename: str) -> dict | None`:
   - Load JSON file from project_dir, return None on error
   - Strip `//` and `/* */` comments before parsing (tsconfig allows comments)
   - Use regex: `re.sub(r'//.*$', '', content, flags=re.MULTILINE)` for single-line
   - Use regex: `re.sub(r'/\*.*?\*/', '', content, flags=re.DOTALL)` for multi-line
   - Catch json.JSONDecodeError and return None

2. `_load_tsconfig_paths(self) -> dict[str, list[str]] | None`:
   - Call `_load_json_safe("tsconfig.json")`
   - If config has `extends` field, also load that base config
   - Merge paths from base config (base first, then override with current)
   - Return `compilerOptions.paths` dict or None
   - Example return: `{"@/*": ["src/*"], "@shared/*": ["src/shared/*"]}`

No new imports needed - `json` and `re` already imported at top of file.
  </action>
  <verify>
Create a temporary test file to verify:
```python
# At end of context_gatherer.py, temporarily add:
if __name__ == "__main__":
    from pathlib import Path
    gatherer = PRContextGatherer(Path("."), 1)
    paths = gatherer._load_tsconfig_paths()
    print(f"Loaded paths: {paths}")
```
Then run: `cd apps/backend && python -c "from runners.github.context_gatherer import PRContextGatherer; from pathlib import Path; g = PRContextGatherer(Path('../../'), 1); print(g._load_tsconfig_paths())"`
  </verify>
  <done>
_load_tsconfig_paths() returns the paths dict from tsconfig.json (or None if no paths configured).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add path alias resolution method</name>
  <files>apps/backend/runners/github/context_gatherer.py</files>
  <action>
Add method `_resolve_path_alias(self, import_path: str, paths: dict[str, list[str]]) -> str | None`:

1. For each pattern in paths dict (e.g., `@/*`):
   - Convert pattern to regex: `@/*` becomes `^@/(.*)$`
   - Use `re.match()` to test import_path
   - If match, extract the suffix (captured group)

2. Replace `*` in target path with extracted suffix:
   - Example: import `@/utils/helpers` with pattern `@/*: [src/*]`
   - Suffix is `utils/helpers`, target becomes `src/utils/helpers`

3. Use first target path (most configs only have one)

4. Return resolved path string or None if no pattern matches

Example:
```python
def _resolve_path_alias(self, import_path: str, paths: dict[str, list[str]]) -> str | None:
    for alias_pattern, target_paths in paths.items():
        # Convert '@/*' to regex pattern '^@/(.*)$'
        regex_pattern = "^" + alias_pattern.replace("*", "(.*)") + "$"
        match = re.match(regex_pattern, import_path)
        if match:
            suffix = match.group(1) if match.lastindex else ""
            # Use first target path, replace * with suffix
            target = target_paths[0].replace("*", suffix)
            return target
    return None
```
  </action>
  <verify>
Test manually:
```python
paths = {"@/*": ["src/*"], "@shared/*": ["src/shared/*"]}
result = gatherer._resolve_path_alias("@/utils/helpers", paths)
# Should return "src/utils/helpers"
```
  </verify>
  <done>
_resolve_path_alias() correctly resolves `@/utils` style imports to actual paths.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend _find_imports with additional patterns</name>
  <files>apps/backend/runners/github/context_gatherer.py</files>
  <action>
Modify the `_find_imports()` method to add three additional patterns for JS/TS files.

Current code (lines 890-898):
```python
if source_path.suffix in [".ts", ".tsx", ".js", ".jsx"]:
    pattern = r"from\s+['\"](\.[^'\"]+)['\"]"
    for match in re.finditer(pattern, content):
        import_path = match.group(1)
        resolved = self._resolve_import_path(import_path, source_path)
        if resolved:
            imports.add(resolved)
```

Replace with extended version:

```python
if source_path.suffix in [".ts", ".tsx", ".js", ".jsx"]:
    # Pattern 1: ES6 relative imports (existing)
    # Matches: from './file', from '../file'
    relative_pattern = r"from\s+['\"](\.[^'\"]+)['\"]"
    for match in re.finditer(relative_pattern, content):
        import_path = match.group(1)
        resolved = self._resolve_import_path(import_path, source_path)
        if resolved:
            imports.add(resolved)

    # Pattern 2: Path alias imports (NEW)
    # Matches: from '@/utils', from '~/config', from '@shared/types'
    alias_pattern = r"from\s+['\"](@[^'\"]+|~[^'\"]+)['\"]"
    ts_paths = self._load_tsconfig_paths()
    if ts_paths:
        for match in re.finditer(alias_pattern, content):
            import_path = match.group(1)
            resolved = self._resolve_path_alias(import_path, ts_paths)
            if resolved:
                # Resolve to actual file path
                full_resolved = self._resolve_import_path("./" + resolved, Path(resolved).parent or source_path)
                if full_resolved:
                    imports.add(full_resolved)

    # Pattern 3: CommonJS require (NEW)
    # Matches: require('./utils'), require('@/config')
    require_pattern = r"require\s*\(\s*['\"]([^'\"]+)['\"]\s*\)"
    for match in re.finditer(require_pattern, content):
        import_path = match.group(1)
        if import_path.startswith("."):
            resolved = self._resolve_import_path(import_path, source_path)
        elif import_path.startswith("@") or import_path.startswith("~"):
            if ts_paths:
                resolved_alias = self._resolve_path_alias(import_path, ts_paths)
                resolved = self._resolve_import_path("./" + resolved_alias, Path(resolved_alias).parent or source_path) if resolved_alias else None
            else:
                resolved = None
        else:
            resolved = None  # Skip node_modules packages
        if resolved:
            imports.add(resolved)

    # Pattern 4: Re-exports (NEW)
    # Matches: export * from './module', export { x } from './module'
    reexport_pattern = r"export\s+(?:\*|\{[^}]*\})\s+from\s+['\"]([^'\"]+)['\"]"
    for match in re.finditer(reexport_pattern, content):
        import_path = match.group(1)
        if import_path.startswith("."):
            resolved = self._resolve_import_path(import_path, source_path)
        elif import_path.startswith("@") or import_path.startswith("~"):
            if ts_paths:
                resolved_alias = self._resolve_path_alias(import_path, ts_paths)
                resolved = self._resolve_import_path("./" + resolved_alias, Path(resolved_alias).parent or source_path) if resolved_alias else None
            else:
                resolved = None
        else:
            resolved = None
        if resolved:
            imports.add(resolved)
```

Note: Cache ts_paths loading to avoid parsing tsconfig.json for every file. Add `self._ts_paths_cache: dict | None = None` in __init__ and check cache first.
  </action>
  <verify>
Run the backend tests to ensure no regressions:
```bash
cd /Users/andremikalsen/Documents/Coding/autonomous-coding && apps/backend/.venv/bin/pytest tests/ -v -k "context" --tb=short 2>/dev/null || echo "No context-specific tests (expected)"
```

Manual verification: Create a test TypeScript file with path aliases and verify detection.
  </verify>
  <done>
`_find_imports()` detects:
- ES6 relative imports: `from './utils'`
- Path alias imports: `from '@/utils'`, `from '~/config'`
- CommonJS requires: `require('./file')`, `require('@/utils')`
- Re-exports: `export * from './module'`
  </done>
</task>

</tasks>

<verification>
1. No test failures in existing tests
2. tsconfig.json paths are loaded correctly
3. Path aliases resolve to actual file paths
4. CommonJS and re-export patterns are detected
</verification>

<success_criteria>
- Path alias imports (`@/`, `~/`) are detected and resolved via tsconfig.json
- CommonJS `require()` statements are detected
- Re-export statements (`export * from`) are detected
- No regressions in existing import detection
</success_criteria>

<output>
After completion, create `.planning/phases/02-context-enrichment/02-01-SUMMARY.md`
</output>
