---
phase: 02-context-enrichment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/backend/runners/github/context_gatherer.py
autonomous: true

must_haves:
  truths:
    - "Python relative imports (from . import, from .. import) are detected"
    - "Python absolute imports (project-internal) are detected"
    - "Imports are resolved to actual file paths when files exist"
  artifacts:
    - path: "apps/backend/runners/github/context_gatherer.py"
      provides: "Python import detection via AST"
      contains: "_find_python_imports"
      contains: "_resolve_python_import"
  key_links:
    - from: "_find_imports()"
      to: "_find_python_imports()"
      via: "method call for .py files"
      pattern: "_find_python_imports"
---

<objective>
Add Python import analysis using the standard library `ast` module.

Purpose: Currently Python imports are explicitly skipped with a TODO comment (lines 900-903). This means Python files in PRs don't get their related files detected, leading to incomplete context.

Output: AST-based Python import detection that resolves both relative and absolute imports to actual file paths.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-context-enrichment/02-RESEARCH.md
@apps/backend/runners/github/context_gatherer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Python import resolution method</name>
  <files>apps/backend/runners/github/context_gatherer.py</files>
  <action>
Add `import ast` at the top of the file (after `import re`).

Add method `_resolve_python_import(self, module_name: str, level: int, source_path: Path) -> str | None`:

This method resolves Python imports to actual file paths.

```python
def _resolve_python_import(
    self, module_name: str, level: int, source_path: Path
) -> str | None:
    """
    Resolve a Python import to an actual file path.

    Args:
        module_name: Module name like 'utils' or 'utils.helpers'
        level: Import level (0=absolute, 1=from ., 2=from .., etc.)
        source_path: Path of file doing the importing

    Returns:
        Resolved path relative to project root, or None if not found.
    """
    if level > 0:
        # Relative import: from . or from ..
        base_dir = source_path.parent
        # level=1 means same package (.), level=2 means parent (..), etc.
        for _ in range(level - 1):
            base_dir = base_dir.parent

        if module_name:
            # from .module import x -> look for module.py or module/__init__.py
            parts = module_name.split(".")
            candidate = base_dir / Path(*parts)
        else:
            # from . import x -> can't resolve without knowing what x is
            return None
    else:
        # Absolute import - check if it's project-internal
        parts = module_name.split(".")
        candidate = Path(*parts)

    # Try as module file (e.g., utils.py)
    file_path = self.project_dir / candidate.with_suffix(".py")
    if file_path.exists() and file_path.is_file():
        try:
            return str(file_path.relative_to(self.project_dir))
        except ValueError:
            return None

    # Try as package directory (e.g., utils/__init__.py)
    init_path = self.project_dir / candidate / "__init__.py"
    if init_path.exists() and init_path.is_file():
        try:
            return str(init_path.relative_to(self.project_dir))
        except ValueError:
            return None

    return None
```

Key points:
- `level=0` means absolute import (`import x` or `from x import y`)
- `level=1` means `from .` (current package)
- `level=2` means `from ..` (parent package)
- Only resolve imports to files that actually exist in the project
  </action>
  <verify>
Test with manual invocation:
```python
from pathlib import Path
# Simulate resolving "from .utils import helper" in apps/backend/core/client.py
result = gatherer._resolve_python_import("utils", 1, Path("apps/backend/core/client.py"))
# Should resolve to apps/backend/core/utils.py if it exists
```
  </verify>
  <done>
_resolve_python_import() resolves Python import strings to file paths for both relative and absolute imports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AST-based Python import extraction</name>
  <files>apps/backend/runners/github/context_gatherer.py</files>
  <action>
Add method `_find_python_imports(self, content: str, source_path: Path) -> set[str]`:

```python
def _find_python_imports(self, content: str, source_path: Path) -> set[str]:
    """
    Find imported files from Python source code using AST.

    Uses ast.parse to extract Import and ImportFrom nodes, then resolves
    them to actual file paths within the project.

    Args:
        content: Python source code
        source_path: Path of the file being analyzed

    Returns:
        Set of resolved file paths relative to project root.
    """
    imports: set[str] = set()

    try:
        tree = ast.parse(content)
    except SyntaxError:
        # Invalid Python syntax - skip gracefully
        return imports

    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            # import module, import module.submodule
            for alias in node.names:
                resolved = self._resolve_python_import(alias.name, 0, source_path)
                if resolved:
                    imports.add(resolved)

        elif isinstance(node, ast.ImportFrom):
            # from module import x, from . import x, from ..module import x
            module = node.module or ""
            level = node.level  # 0=absolute, 1=from ., 2=from .., etc.
            resolved = self._resolve_python_import(module, level, source_path)
            if resolved:
                imports.add(resolved)

    return imports
```

Key points:
- Use ast.walk() to traverse all nodes (simpler than NodeVisitor for this use case)
- Handle ast.Import for `import x` statements
- Handle ast.ImportFrom for `from x import y` statements
- Gracefully skip files with syntax errors
  </action>
  <verify>
Test with a real Python file:
```python
content = '''
from pathlib import Path
from .utils import helper
from ..core import client
import json
'''
result = gatherer._find_python_imports(content, Path("apps/backend/agents/coder.py"))
# Should find project-internal imports only
```
  </verify>
  <done>
_find_python_imports() extracts imports from Python source using AST and resolves them to file paths.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Python import detection into _find_imports</name>
  <files>apps/backend/runners/github/context_gatherer.py</files>
  <action>
Update the `_find_imports()` method to call `_find_python_imports()` for Python files.

Replace the current Python handling (lines 900-903):
```python
elif source_path.suffix == ".py":
    # Python relative imports are complex, skip for now
    # Could add support for "from . import" later
    pass
```

With:
```python
elif source_path.suffix == ".py":
    # Python imports via AST
    imports.update(self._find_python_imports(content, source_path))
```

This is a simple one-line change that delegates to the new method.
  </action>
  <verify>
Run backend tests:
```bash
cd /Users/andremikalsen/Documents/Coding/autonomous-coding && apps/backend/.venv/bin/pytest tests/ -v --tb=short 2>&1 | head -50
```

Manual test with actual Python file:
```bash
cd /Users/andremikalsen/Documents/Coding/autonomous-coding/apps/backend && python -c "
from runners.github.context_gatherer import PRContextGatherer
from pathlib import Path

gatherer = PRContextGatherer(Path('../..'), 1)
content = open('agents/coder.py').read()
imports = gatherer._find_python_imports(content, Path('apps/backend/agents/coder.py'))
print(f'Found {len(imports)} imports:')
for imp in sorted(imports)[:10]:
    print(f'  - {imp}')
"
```
  </verify>
  <done>
Python files now have their imports detected and resolved to file paths, instead of being skipped.
  </done>
</task>

</tasks>

<verification>
1. No syntax errors in modified file
2. No test failures
3. Python relative imports (from . import) are detected
4. Python absolute imports (project-internal only) are detected
5. External packages (like `import json`) are correctly ignored
</verification>

<success_criteria>
- Python relative imports (`from . import`, `from .. import`) are detected
- Python absolute imports that correspond to project files are detected
- External library imports are not included (no resolution)
- SyntaxError in Python files doesn't crash the gatherer
</success_criteria>

<output>
After completion, create `.planning/phases/02-context-enrichment/02-02-SUMMARY.md`
</output>
